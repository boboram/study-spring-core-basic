# study-spring-core-basic
스프링 핵심 원리 기본편 스터디

# 빈 스코프

## 빈 스코프란? 
- 스프링 빈이 스프링 컨테이너의 시작과 함께 생성되어서 스프링 컨테이너가 종료될 때 까지 유지되는 이유는 스프링 빈이 기본적으로 싱글톤 스코프로 생성되기 때문
  - 스코프는 빈이 존재할 수 있는 범위 
- 스프링에서 지원하는 스코프 
  - 싱글톤 : 스프링 컨테이너의 시작~종료까지 유지되는 가장 넓은 범위의 스코프
  - 프로토타입 : 프로토타입 빈의 생성과 의존관계 주입까지만 관여, 매우 짧은 범위의 스코프
  - 웹 관련 스코프 
    - request
    - session
    - application 

## 프로토타입 스코프
- 항상 새로운 인스턴스 생성 후 반환 
- **스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다는 것** 
  - 클라이언트에 빈 반환 -> 생성된 빈을 관리하지 않음 
  - `@PreDestroy` 메서드 호출 X 
- 스프링 컨테이너에서 빈 조회시 생성, 초기화 메서드도 실행 
- 특징 
  - 요청시마다 새로 생성
  - 종료 메서드 호출 X 
  - 프로토타입 빈을 조회한 클라이언트가 빈을 관리해야함 

## 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점 
- `SingletonWithPrototypeTest1.java` 
- 새로 생성되기를 원하는데 빈 주입 시점에만 새로 생성되기 때문에 사용시마다 새로 생성되지 않음 

## 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 Provider 로 문제 해결
- `ObjectProvider`: 지정 빈을 컨테이너에 대신 찾아주는 DL(Dependency Lookup)서비스를 제공하는 것 
  - 스프링에 의존  
스프링에 의존하지 않는 새로운 기술이 나오는데..
- JSR-330 Provider 
  - gradle 에 `javax.inject:javax.inject:1` 라이브러리 별로도 추가
  - 딱 필요한 DL 정도의 기능만 제공
  - `get()` 메서드 하나로 기능이 매우 단순 
  - 자바 표준이기에 스프링 외에도 사용 가능  

### 프로토타입 빈은 언제 사용? 
- 매번 사용할 때 마다 의존관계 주입이 완료된 새로운 객체가 필요하면 사용하면 된다. 
- 실무에서 웹 애플리케이션을 개발해보면, 싱글톤 빈으로 대부분의 문제를 해결할 수 있기 때문에 **프로토타입 빈을 직접적으로 사용하는 일은 매우 드물다**. 
- 대부분 스프링이 더 다양하고 편리한 기능을 제공해주기 때문에, 특별히 다른 컨테이너를 사용할 일이 없다면, 스프링이 제공하는 기능을 사용하면 된다. 

## 웹 스코프 
- 웹 환경에서만 동작 
- 스코프의 종료시점까지 관리 -> 종료 메서드 호출 
- HTTP request 요청 당 각각 할당되는 request 스코프  

## request 스코프 예제 만들기
- `implementation 'org.springframework.boot:spring-boot-starter-web'` 추가 
  - 내장 톰켓 서버를 활용해서 웹 서버와 스프링을 함께 실행 

### request 스코프 예제 개발 
- `MyLogger`
  - 동시에 여러 HTTP 이 온 경우 구분하기 위함 
    - 기대 포멧 [UUID][requestURL][message] 
  - myLogger 는 HTTP 요청 당 각각 구분되므로 다른 HTTP 요청 때문에 값이 섞이는 걱정은 하지 않아도 됨 
  - 실행시점시 오류 발생
    - request 스코프 빈은 아직 생성되지 않았다(고객의 요청이 와야 생성 가능하다)
- `ObjectProvider` 덕분에 `ObjectProvider.getObject()`를 호출하는 시점까지 request scope 빈의 생성을 지연 가능 
  - `ObjectProvider.getObject()` 호출 시점에는 HTTP 요청이 진행중이므로 request scope 빈의 생성이 정상 처리 
  - `ObjectProvider.getObject()`를 LogDemoController, LogDemoService 에서 각각 한번씩 따로 호출해도 **같은 HTTP 요청이면 같은 스프링 빈이 반환** 

## 스코프와 프록시
- `@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)`
- **가짜 프록시 객체는 요청이 오면 그때 내부에서 진짜 빈을 요청하는 위임 로직이 들어있다.**
- 클라이언트가 `myLogger.logic()` 호출시 가짜 프록시 객체 메서드를 호출한 것이고 가짜 프록시 객체는 request 스코프의 진짜 `myLogger.logic()`을 호출한다. 
- 가짜 프록시 객체는 원본 클래스를 상속 받아서 만들어졌기에 이 객체를 사용하는 클라이언트 입장에서는 사실 원본인지 아닌지도 모르게, 동일하게 사용할 수 있다(다형성)
- **동작 원리** 
  - CGLIB라는 라이브러리로 내 클래스를 상속 받은 가짜 프록시 객체를 만들어서 주입한다. 
  - 이 가짜 프록시 객체는 실제 요청이 오면 그때 내부에서 실제 빈을 요청하는 위임 로직이 들어있다.
  - 가짜 프록시 객체는 실제 reuqest scope와는 관계가 없다. 그냥 가짜이고, 내부에 단순한 위임 로직만 있고, 싱글톤처럼 동작한다. 
- **특징 정리** 
  - 프록시 객체 덕분에 클라이언트는 마치 싱글톤 빈을 사용하듯이 편리하게 request scope를 사용 가능 
  - 사실 Provider를 사용하든, 프록시를 사용하든 핵심 아이디어는 진짜 **객체 조회를 꼭 필요한 시점까지 지연처리 한다는 점**이다.
  - 단지 애노테이션 설정 변경만으로 원본 객체를 프록시 객체로 대체할 수 있다. 이것이 바로 다형성과 DI 컨테이너가 가진 큰 강점이다. 
  - 꼭 웹 스코프가 아니어도 프록시는 사용할 수 있다. 
- **주의점** 
  - 싱글톤처럼 보이지만 따로 생성되는 것 -> 주의해서 사용해야 함
  - 이런 특별한 scope 는 꼭 필요한 경우에만 사용하자. 